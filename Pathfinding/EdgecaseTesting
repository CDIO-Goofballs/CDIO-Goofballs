import unittest
import random
from Pathing import path_finding
from Polygons import convert_cross_to_polygons, create_egg
from shapely.geometry import Point, Polygon
from unittest.mock import patch


def generate_random_cross(center_x, center_y, size=20):
    half = size / 2
    top = (center_x, center_y + half)
    bottom = (center_x, center_y - half)
    right = (center_x + half, center_y)
    left = (center_x - half, center_y)
    return (top, bottom, right, left)


class TestPathFinding(unittest.TestCase):
    def test_random_path_finding_multiple_runs(self):
        width, height = 160, 120
        wall_corners = ((0, 0), (0, height), (width, height), (width, 0))

        for _ in range(5):
            margin = 20
            offset_height = height - margin
            offset_width = width - margin
            cx = random.uniform(width / 2 - 10, width / 2 + 10)
            cy = random.uniform(height / 2 - 10, height / 2 + 10)
            cross = None
            robot_radius = 10.5

            start = (random.uniform(margin, offset_width), random.uniform(margin, offset_height))
            end = (random.uniform(margin, offset_width), random.uniform(margin, offset_height))
            num_objects = random.randint(0, 10)
            balls = [(random.uniform(5, width - 5), random.uniform(5, height - 5)) for _ in range(num_objects)]
            vip = (random.uniform(margin, offset_width), random.uniform(margin, offset_height)) if random.choice([True, False]) else None
            egg = None

            path = path_finding(cross=cross, egg=egg, start=start, vip=vip, balls=balls, end=end,
                                wall_corners=wall_corners, robot_radius=robot_radius, width=width, height=height, debug=False)

            self.assertIsInstance(path, list)

            obstacles = []
            obstacles += convert_cross_to_polygons(cross, 3)
            obstacles += create_egg(egg, 4.5) if egg else []
            inflated_obstacles = [obs.buffer(robot_radius).simplify(1.5) for obs in obstacles]
            if any(obs.contains(Point(start)) or obs.contains(Point(end)) for obs in inflated_obstacles):
                self.assertEqual(len(path), 0, "There should be no path if start or end is inside an obstacle")
            else:
                self.assertGreater(len(path), 0, "Path should not be empty")

    def test_start_equals_end(self):
        width, height = 160, 120
        point = (80, 60)
        cross = generate_random_cross(80, 60)
        robot_radius = 10.5

        path = path_finding(cross=cross, egg=None, start=point, vip=None, balls=[], end=point,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertEqual(len(path), 2)  # Possibly start and end as separate MyPoints
        self.assertEqual((path[0].x, path[0].y), point)
        self.assertEqual((path[-1].x, path[-1].y), point)

    def test_start_inside_obstacle(self):
        width, height = 160, 120
        cross = generate_random_cross(80, 60)
        robot_radius = 10.5
        obstacles = convert_cross_to_polygons(cross, 3)
        start = list(obstacles[0].centroid.coords)[0]
        end = (150, 110)

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertEqual(len(path), 0)

    def test_start_outside_bounds(self):
        width, height = 160, 120
        start = (-10, -10)
        end = (80, 60)
        robot_radius = 10.5

        path = path_finding(cross=None, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertEqual(len(path), 0)

    def test_end_inside_obstacle(self):
        width, height = 160, 120
        cross = generate_random_cross(80, 60)
        robot_radius = 10.5
        obstacles = convert_cross_to_polygons(cross, 3)
        start = (10, 10)
        end = list(obstacles[0].centroid.coords)[0]

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertEqual(len(path), 0)

    def test_completely_blocked_path(self):
        width, height = 160, 120
        robot_radius = 10.5
        cross = ((80, 110), (80, 10), (110, 60), (50, 60))  # Large vertical and horizontal bars in the center
        start = (20, 60)
        end = (140, 60)

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertEqual(len(path), 0)
    
    def test_path_around_border(self):
        width, height = 160, 120
        robot_radius = 10.5
        cross = ((80, 110), (80, 10), (110, 60), (50, 60))
        start = (20, 60)
        end = (140, 60)

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)

    def test_dense_ball_clustering(self):
        width, height = 160, 120
        robot_radius = 10.5
        cluster_center = (80, 60)
        balls = [(cluster_center[0] + dx, cluster_center[1] + dy) for dx in range(-5, 6, 2) for dy in range(-5, 6, 2)]
        start = (20, 60)
        end = (140, 60)

        path = path_finding(cross=None, egg=None, start=start, vip=None, balls=balls, end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)

    def test_very_small_map(self):
        width, height = 25, 25
        start = (5, 5)
        end = (20, 20)
        robot_radius = 10

        path = path_finding(cross=None, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertTrue(isinstance(path, list))

    def test_narrow_passage(self):
        width, height = 100, 100
        cross = ((45, 0), (55, 0), (55, 100), (45, 100))  # Vertical wall with 10-unit gap
        start = (10, 50)
        end = (90, 50)
        robot_radius = 5  # Fits exactly through the 10-unit gap

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)
    
    def test_vip_present_but_not_blocking(self):
        width, height = 160, 120
        robot_radius = 10.5
        vip = (30, 30)
        start = (20, 20)
        end = (140, 100)

        path = path_finding(cross=None, egg=None, start=start, vip=vip, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)
    
    def test_ball_directly_on_straight_path(self):
        width, height = 100, 100
        start = (10, 10)
        end = (90, 90)
        balls = (50, 50)  # Right in the middle of the direct path
        robot_radius = 10.5
    
        path = path_finding(cross=None, egg=None, start=start, vip=None, balls=balls, end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)
    
        self.assertGreater(len(path), 0)

    def test_large_map(self):
        width, height = 1000, 1000
        start = (100, 100)
        end = (900, 900)
        robot_radius = 10

        path = path_finding(cross=None, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)

    def test_obstacle_touching_border(self):
        width, height = 100, 100
        cross = ((0, 10), (0, 90), (10, 90), (10, 10))  # Obstacle flush with left wall
        start = (20, 50)
        end = (90, 50)
        robot_radius = 5

        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)

        self.assertGreater(len(path), 0)

    def test_diagonal_wall_channel(self):
        width, height = 100, 100
        cross = ((20, 80), (80, 20), (85, 25), (25, 85))  # Diagonal cross
        start = (10, 10)
        end = (90, 90)
        robot_radius = 4
    
        path = path_finding(cross=cross, egg=None, start=start, vip=None, balls=[], end=end,
                            wall_corners=((0, 0), (0, height), (width, height), (width, 0)),
                            robot_radius=robot_radius, width=width, height=height, debug=False)
    
        self.assertGreater(len(path), 0)

if __name__ == "__main__":
    unittest.main()
